var util = require('util');
var request = require('request');
var OAuth = require('oauth');

/**
 * config:
 *  auth: {
 *     type - currently only 'oauth1' is supported
 *     consumer_key - consumer key for the API (get from BitBucket integration dashboard)
 *     private_key - private key for the API (get from BitBucket integration dashboard)
 *     token - token that was generated by BitBucket for the user
 *     token_secret - token secret that was generated by BitBucket for the user
 *  }
 *  url: the URL of the BitBucket server
 */
function Bitbucket(config){
  this.config = config || {};

  this.authenticate(config.auth);

  if(!config.url){
    throw new Error("Bitbucket url config missing");
  }
  this.url = config.url

  // bind all methods to this so context of this.repos.method is still this.
  // console.log("binding to this", this);

  var subs = ["repos", "statuses"],
      sub, method;
  for(var i in subs){
    sub = subs[i];
    for(var m in this[sub]){
      method = this[sub][m];
      if(typeof method.bind == "function"){
        this[sub][m] = method.bind(this)
      }
    }
  }
}

Bitbucket.prototype.utils = {
  extend: function(dest, src){
    dest = dest || {};
    src = src || {};

    var ret = {}, x;

    for(x in dest){
      ret[x] = dest[x];
    }

    for(x in src){
      ret[x] = src[x];
    }

    return ret;
  },

  defaults: function(dest, src){
    dest = dest || {};
    src = src || {};

    var ret = {}, x;

    for(x in dest){
      ret[x] = dest[x];
    }

    for(x in src){
      if(typeof dest[x] == "undefined"){
        ret[x] = src[x];
      }
    }

    return ret;
  }
}

/**
 * Synchronous call that sets up the HTTP client with the proper auth
 */
Bitbucket.prototype.authenticate = function(auth){
  if(!auth){
    throw new Error("Bitbucket authentication config missing");
  }

  if(auth.type == 'oauth1'){
    this.oauth = {
      consumer_key: auth.consumerKey
    , private_key: auth.consumerSecret
    , token: auth.token
    , token_secret: auth.token_secret
    , signature_method : 'RSA-SHA1'
    };
  } else {
    throw new Error("Bitbucket authentication only supports 'oauth1' type");
  }
}

/**
 * Synchronous call that sets up the HTTP client with the proper auth
 * opts:
 *  - path: Bitbucket request path
 *  - method: HTTP method (defaults to GET)
 */
Bitbucket.prototype.getAuthHeader = function(opts){
  var uri = this.url + opts.path
  opts.method = opts.method || "GET"

  var oauth = new OAuth.OAuth(
    null,
    null,
    this.oauth.consumer_key,
    this.oauth.private_key,
    '1.0',
    null,
    this.oauth.signature_method
  );

  var authorization = oauth._buildAuthorizationHeaders(oauth._prepareParameters(
    this.oauth.token, this.oauth.token_secret, opts.method, uri
  ));

  return authorization
}

/**
 * opts: all standard request call options with the addition of the following (that
 * don't get passed to request):
 *
 * method - lowercases HTTP method, with "del" instead of "DELETE" (defaults to "get")
 * path (appended to this.url)
 */
Bitbucket.prototype.http = function(opts, cb){
  opts = opts || {};
  var method = opts.method || "get";

  opts = this.utils.defaults(opts, {
    uri: this.url + opts.path,
    oauth: this.oauth,
    json: true
  });

  delete opts.method
  delete opts.path

  function handler(err, res, body){
    if(err) return cb(err)

    if(!(res.statusCode >=200 && res.statusCode <300)){
      err = new Error(JSON.stringify(body))
      err.statusCode = res.statusCode
      err.statusMessage = res.statusMessage

      return cb(err)
    }

    cb(err, res, body)
  }

  return request[method](opts, handler);
}

// need:
//   repos
//     getAll
//     getContent (directory and file contents)
//       - getContent({user: project.owner, repo: project.repo, ref: sha, path: ''})
//       - getContent({user: project.owner, repo: project.repo, ref: sha, path: file.path})
//   statuses
//     create

Bitbucket.prototype.repos = {
  getAll: function(opts, cb){
    if(typeof opts == "function"){
      cb = opts;
      opts = {};
    }

    var params = this.utils.defaults(opts, {
      qs: {limit: 100, permission: "REPO_ADMIN"},
      path: "/rest/api/1.0/repos"
    });

    this.http(params, function (err, res, repos) {
      if(err) return cb(err);

      // repos:
      // "size": 1,
      //     "limit": 25,
      //     "isLastPage": true,
      //     "values": [
      //         {
      //             "slug": "my-repo",
      //      ...

      // drill down into actual repos array
      repos = repos.values;

      cb(err, repos);
    });
  },

  /**
   * Gets content of files (path specified) or directories (no path)
   */
  getContent: function(opts, cb){
    if(typeof opts == "function"){
      cb = opts;
      opts = {};
    }

    if(!opts.projectKey){
      return cb(new Error("getContent projectKey required"))
    }
    if(!opts.repositorySlug){
      return cb(new Error("getContent repositorySlug required"))
    }

    opts.path = opts.path || '';

    var path = util.format("/rest/api/1.0/projects/%s/repos/%s/browse/%s",
                           opts.projectKey, opts.repositorySlug, opts.path);

    delete opts.path;

    var qs = {
      at: opts.at || opts.ref, // support 'ref' instead of 'at' too
      type: opts.type,
      blame: opts.blame,
      noContent: opts.noContent
    }
    delete opts.at;
    delete opts.ref;
    delete opts.type;
    delete opts.blame;
    delete opts.noContent;

    var params = this.utils.defaults(opts, {
      qs: qs, path: path
    });

    this.http(params, function (err, res, content) {
      if(err) return cb(err);

      //content:
      // {
      //   "size": 1,
      //   "limit": 25,
      //   "isLastPage": true,
      //   "start": 0,
      //   "lines": [
      //     {
      //       "text": "print('hello world')"
      //     }
      //   ]
      // }

      // console.log("content", util.inspect(content, null, 5));

      if(content.lines){
        // getting contents of a file
        content = content.lines.map(function(entry){
                  return entry.text }).join("\n");
      } else if(content.path){
        content = content.children.values
      }

      cb(err, content);
    });
  }
}

Bitbucket.prototype.statuses = {
  create: function(status, opts, cb){
    if(typeof opts == "function"){
      cb = opts;
      opts = {};
    }

    // validate status
    if(!status){
      return cb(new Error("statuses.create status required"));
    }

    var required_status_fields = ["state", "key", "url"],
        field;
    for(var i in required_status_fields){
      field = required_status_fields[i];
      if(!status[field]){
        return cb(new Error("statuses.create status." + field + " required"));
      }
    }

    // automatically uppcase state
    status.state = status.state.toUpperCase();
    var valid_states = ["SUCCESSFUL", "FAILED", "INPROGRESS"];
    if(valid_states.indexOf(status.state) < 0 ){
      return cb(new Error("statuses.create status." + field + " required to be one of " + ["SUCCESSFUL", "FAILED", "INPROGRESS"].join(", ")));
    }

    // validate opts
    if(!opts.commitId && !opts.ref){
      return cb(new Error("statuses.create commitId or ref config required"))
    }

    var ref = opts.commitId || opts.ref;
    var path = util.format("/rest/build-status/1.0/commits/%s",
                           ref);

    delete opts.commitId;
    delete opts.ref;

    var params = this.utils.defaults(opts, {
      path: path,
      method: "post",
      body: status,
      json: true
    });

    this.http(params, function (err, res, content) {
      if(err) return cb(err);

      if(content && content.errors){
        return cb(new Error(content.errors[0].message));
      }

      cb(err, content);
    });
  }
}


module.exports = Bitbucket
